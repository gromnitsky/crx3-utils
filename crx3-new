#!/usr/bin/env node

let crypto = require('crypto')
let path = require('path')
let fs = require('fs')
let Pbf = require('pbf')
let crx3_pb = require('./crx3_pb')

async function main() {
    if (!process.argv[2]) err(`Usage: ${progname()} private.pem < file.zip`)

    let [kp, zipdata] = await Promise.all([keypair(process.argv[2]), read()])
	.catch(err)

    let crx = new CrxFile(kp, zipdata)
    process.stdout.write(crx.creat())
}

function keypair(file) {
    return read(file).then( r => ({
	public_der: crypto.createPublicKey(r)
	    .export({type: 'spki', format: 'der'}),
	private: crypto.createPrivateKey(r)
    }))
}

class CrxFile {
    constructor(keypair, payload) {
	this.key = keypair
	this.payload = payload
    }

    id() {
	return crypto.createHash('sha256')
	    .update(this.key.public_der).digest().slice(0, 16)
    }

    signed_data() {
	let pb
	return this._signed_data || ( // memoization
	    pb = new Pbf(),
	    crx3_pb.SignedData.write({crx_id: this.id()}, pb),
	    this._signed_data = pb.finish()
	)
    }

    sign() {
	let magic_str = "CRX3 SignedData\x00"
	return crypto.createSign('sha256')
	    .update(magic_str)
	    .update(len(this.signed_data()))
	    .update(this.signed_data())
	    .update(this.payload)
	    .sign(this.key.private)
    }

    header() {
	let pb = new Pbf()
	crx3_pb.CrxFileHeader.write({
	    sha256_with_rsa: [{	// AsymmetricKeyProof
		public_key: this.key.public_der,
		signature: this.sign()
	    }],
	    signed_header_data: this.signed_data()
	}, pb)
	return pb.finish()
    }

    creat() {
	let magic_str = Buffer.from('Cr24')
	let version = len('xxx')
	let header_size = len(this.header())

	return Buffer.concat([magic_str, version, header_size, this.header(),
			      this.payload])
    }
}

function len(o) {		// 4 bytes, little-endian
    let buf = Buffer.alloc(4)
    buf.writeUInt32LE(o.length, 0)
    return buf
}

function read(file) {
    let stream = file ? fs.createReadStream(file) : process.stdin
    let data = []
    return new Promise( (resolve, reject) => {
	stream.on('error', reject)
	stream.on('data', chunk => data.push(chunk))
	stream.on('end', () => resolve(Buffer.concat(data)))
    })
}

function err(s) {
    console.error(progname(), 'error:', s instanceof Error ? s.message : s)
    process.exit(1)
}

function progname() { return path.basename(process.argv[1]) }

main()
